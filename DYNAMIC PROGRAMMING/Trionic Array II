class Solution {
public:
    // memoization
    long long solve(int i, int trend, vector<int> &nums, vector<vector<long long>> &dp){
        int n = nums.size();
        if(i == n) return trend == 3 ? 0 : LLONG_MIN;
        if(dp[i][trend] != -1) return dp[i][trend];
        long long noTake = LLONG_MIN / 2;
        long long take = LLONG_MIN / 2;

        if(trend == 0) noTake = solve(i+1, 0, nums, dp); 
        if(trend == 3) take = nums[i];
        if(i+1 < n){
            int curr = nums[i], next = nums[i+1];
            if(trend == 0 && next > curr){
                take = max(take, nums[i] + solve(i+1, 1, nums, dp));
            }

            if(trend == 1 && next > curr){
                take = max(take, nums[i] + solve(i+1, 1, nums, dp));
            } 
            else if(trend == 1 && next < curr){
                take = max(take, nums[i] + solve(i+1, 2, nums, dp));
            }

            if(trend == 2 && next < curr){
                take = max(take, nums[i] + solve(i+1, 2, nums, dp));
            }
            else if(trend == 2 && next > curr){
                take = max(take, nums[i] + solve(i+1, 3, nums, dp));
            }

            if(trend == 3 && next > curr){
                take = max(take, nums[i] + solve(i+1, 3, nums, dp));
            }
        }
        return dp[i][trend] = max(take, noTake);
    }

    long long maxSumTrionicc(vector<int>& nums) {
        int n = nums.size();
        vector<vector<long long>> dp(n, vector<long long>(5, -1));
        return solve(0, 0, nums, dp);
    }

    // tabulation
    long long maxSumTrionic(vector<int>& nums) {
        int n = nums.size();
        vector<vector<long long>> dp(n+1, vector<long long>(5, LLONG_MIN));
        for(int i=0; i<n; i++){
            dp[i][3] = 0;
        }
        
        for(int trend = 3; trend >= 0; trend--){
            for(int i = n-1; i >= 0; i--){
                long long noTake = LLONG_MIN / 2;
                long long take = LLONG_MIN / 2;

                if(trend == 0) noTake = dp[i+1][0]; 
                if(trend == 3) take = nums[i];
                if(i+1 < n){
                    int curr = nums[i], next = nums[i+1];
                    if(trend == 0 && next > curr){
                        take = max(take, nums[i] + dp[i+1][1]);
                    }

                    if(trend == 1 && next > curr){
                        take = max(take, nums[i] + dp[i+1][1]);
                    } 
                    else if(trend == 1 && next < curr){
                        take = max(take, nums[i] + dp[i+1][2]);
                    }

                    if(trend == 2 && next < curr){
                        take = max(take, nums[i] + dp[i+1][2]);
                    }
                    else if(trend == 2 && next > curr){
                        take = max(take, nums[i] + dp[i+1][3]);
                    }

                    if(trend == 3 && next > curr){
                        take = max(take, nums[i] + dp[i+1][3]);
                    }
                }
                dp[i][trend] = max(take, noTake);
            }
        }
        return dp[0][0];
    }
};
