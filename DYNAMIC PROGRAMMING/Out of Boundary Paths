class Solution {
public:
    vector<pair<int, int>> dir = {{0,1}, {0,-1}, {1,0}, {-1,0}};
    const int MOD = 1e9 + 7;
    // memoization
    int solve(int i, int j, int m, int n, int k, vector<vector<vector<int>>> &dp){
        if(i < 0 || i >= m || j < 0 || j >= n) return 1;
        if(k == 0) return 0;
        if(dp[i][j][k] != -1) return dp[i][j][k];
        int paths = 0;
        for(auto[dx, dy] : dir){
            paths = (paths + solve(i+dx, j+dy, m, n, k-1, dp))% MOD;
        }
        return dp[i][j][k] = paths;
    }

    int findPathss(int m, int n, int k, int row, int col) {
        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k+1, -1)));
        return solve(row, col, m, n, k, dp);
    }

    // tabulation
    int findPaths(int m, int n, int k, int row, int col){
        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(k+1, 0)));
        for(int move = 1; move <= k; move++){
            for(int i = 0; i < m; i++){
                for(int j = 0; j < n; j++){
                    long long paths = 0;
                    for(auto[dx, dy] : dir){
                        int nr = i+dx, nc = j+dy;
                        if(nr < 0 || nr >= m || nc < 0 || nc >= n) paths++;
                        else paths += dp[nr][nc][move-1];
                    }
                    dp[i][j][move] = paths % MOD;  
                }
            }
        }
        return dp[row][col][k];
    }
};
