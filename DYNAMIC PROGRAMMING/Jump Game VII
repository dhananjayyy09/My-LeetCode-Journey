class Solution {
public:
    // memoization
    bool solve(int i, string &s, int minJp, int maxJp, vector<int> &dp){
        int n = s.size();
        if(i == n-1) return true;
        if(dp[i] != -1) return dp[i];
        bool ans = false;
        for(int j = i + minJp; j <= min(i + maxJp, n-1); j++){
            if(s[j] == '0'){
                ans |= solve(j, s, minJp, maxJp, dp);
            }
        }
        return dp[i] = ans;
    }

    bool canReachh(string s, int minJp, int maxJp) {
        int n = s.size();
        vector<int> dp(n, -1);
        return solve(0, s, minJp, maxJp, dp);
    }

    // tabulation
    bool canReachhh(string s, int minJp, int maxJp) {
        int n = s.size();
        vector<int> dp(n+1, false);
        dp[n - 1] = (s[n - 1] == '0');
        for(int i = n-2; i >= 0; i--) {
            if (s[i] == '1') continue;
            bool ans = false;
            for(int j = i + minJp; j <= min(i + maxJp, n - 1); j++){
                if(dp[j]) {
                    ans = true;
                    break;
                }
            }
            dp[i] = ans;
        }
        return dp[0];
    }

    // optimal -> right
    bool canReach(string s, int minJp, int maxJp) {
        int n = s.size();
        vector<int> dp(n, false);
        dp[0] = true;
        int farthest = 0;
        for(int i = 0; i < n; i++){
            if(!dp[i]) continue;
            int start = max(i + minJp, farthest);
            int end = min(n-1, i + maxJp);
            for(int j = start; j <= end; j++){
                if(s[j] == '0'){
                    dp[j] = true;
                }
            }
            farthest = end + 1;
        }
        return dp[n-1];
    }
};
